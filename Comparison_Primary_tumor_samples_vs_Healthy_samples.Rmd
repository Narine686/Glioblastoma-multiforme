---
title: "Comparison Primary tumor samples vs Healthy samples"
author: "Narine Fischer Albiol"
date: "2024-10-28"
output: html_document
bibliography: references.bib
csl: apa.csl
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

The following workflow uses R language [@rsoftware] to carry out a Differential Expression Analysis (DEA) using data obtained from the Genomic Data Commons Data Portal [@gdcportal]. RNA-seq expression data in samples of patients with glioblastoma multiforme (GM) was analyzed against healthy samples. From the differentially expressed genes (DEG), the desired ones (_CDH1_, _CDH2_, _L1CAM_, _EPCAM_, _EGFR_, _NANOG_, _ALDH1A1_, _OCT4_, _ABCG2_, _HRAS_, _KRAS_, _NRAS_, _GAPDH_, _PIK3CB_) were filtered to see how their expression changes between the two types of samples.

## Needed libraries

The libraries used come from both CRAN [@cran] and Bioconductor [@bioconductor]. 
```{r libraries}
library(TCGAbiolinks)
library(edgeR)
library(geneplotter)
library(limma)
library(sva)
library(dplyr)
library(ggplot2)
library(tidyr)
library(rlist)
library(openxlsx)
```

## Data download

As previously stated, the data will be obtained from the Genomic Data Commons data portal [@gdcportal], a repository with data from projects studying cancer. In this case, the data will be downloaded from the project TCGA-GBM, with data specific to glioblastoma multiforme. Therefore, The results published here are in whole or part based upon data generated by The Cancer Genome Atlas managed by the NCI and NHGRI. Information about TCGA can be found at http://cancergenome.nih.gov .The RNA-seq data obtained during this project will be the one selected. For this step, the package `TCGAbiolinks` will be used [@TCGAbiolinks].
```{r data_download}
# Generate query to obtain the RNA-Seq data from the TCGA-GBM project
query_rnaseq <- GDCquery(
  project = "TCGA-GBM",
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  experimental.strategy = "RNA-Seq",
  access = "open"
)

# Download the RNA-Seq data
GDCdownload(query_rnaseq, method = "client")

# Prepare RNA-Seq data for analysis, creating a SummarizedExperiment object
rnaseq_data <- GDCprepare(query_rnaseq)
```

In the `rnaseq_data` object, there are 60660 genes by 176 samples. Looking at the data of the columns (samples) (`colData(rnaseq_data)`), it can be seen in `definition` that samples pertain to three different groups: Primary solid Tumor (158), Recurrent Solid Tumor (13), and Solid Tissue Normal (5). 
It can be seen that the number of Primary solid Tumor samples is higher than the number of Solid Tissue Normal samples.

# Quality assessment and processing of data

## Observation of possible confounding variables

As the intent of this workflow is to compare primary tumor samples against healthy samples, the `rnaseq_data` will be filtered to only obtain these two types of samples. Moreover a DGELISt object will be created for further analyses. 
```{r filter_rnsaseq_data}
# Filter for healthy and primary tumor samples
rnaseq_data_hp <- rnaseq_data[, colData(rnaseq_data)$definition %in% c("Solid Tissue Normal", "Primary solid Tumor")]

# Create a DGEList object for the analysis
dge <- DGEList(counts=assays(rnaseq_data_hp)$unstranded, genes=rowData(rnaseq_data_hp),
                 samples=colData(rnaseq_data_hp))
```

The sequencing depth per sample will be mapped and colored according to a variable that is believed that might cause a confounding effect. The first variable to be observed is `gender`. The aim is to see if there is any difference in sequencing depth due to gender, this should be done with any variable that wants to be investigated. A graph with the ordered sequencing depths and colored by `gender` is created.
```{r quality_assessment_gender}
# Quality assessment: depth sequencing - gender
ord <- order(dge$sample$lib.size)
rnaseq_data_hp$gender<-factor(rnaseq_data_hp$gender)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("red", "blue")[rnaseq_data_hp$gender[ord]])
legend("topleft", c("female", "male"), fill=c("red", "blue"), inset=0.01)
```

There are some considerable differences in sequencing depth per sample, ranging from 7 to 80 million reads; therefore, normalization within samples is needed. Furthermore, it appears that gender could act as a confounding factor in subsequent analyses, as many samples classified as "female" cluster at the low coverage end of the graph, this possible confounding effect will be taken into account during the Differential Expression Analysis (DEA). Moreover, it is visible that some samples do not present a value assigned for `gender`. 

The next variable to be assessed is `race`.
```{r quality_assessment_race}
# Quality assessment: depth sequencing - race. A graph with the ordered sequencing depths and colored by race is created.
rnaseq_data_hp$race<-factor(rnaseq_data_hp$race)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("green", "yellow", "#ED3EF7", "#FF885B")[rnaseq_data_hp$race[ord]])
legend("topleft", c("asian", "black or african american", "not reported", "white"), fill=c("green", "yellow", "#ED3EF7", "#FF885B"), inset=0.01)
```

It can be seen that most of the sample come from a white population. It is not possible to actually discern if any confounding effect may be affecting our data due to differences in sequencing depth by `race`. Therefore, it has been decided to take the variable into account for the DEA. As with `gender`, there are some samples without a value assigned. 

It will also be seen if there is any distinction in sequencing depth depending on the target variable, `definition`.
```{r quality_assessment_definition}
# Quality assessment: depth sequencing - definition. A graph with the ordered sequencing depths and colored by definition is created
rnaseq_data_hp$definition<-factor(rnaseq_data_hp$definition)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("brown", "lightpink")[rnaseq_data_hp$definition[ord]])
legend("topleft", c("Primary solid Tumor", "Solid Tissue Normal"), fill=c("brown", "lightpink"), inset=0.01)
```

As with `race`, due to the low amount of samples for `Solid Tissue Normal`, it can not be discerned if there is any relation between sequencing depth and the cancer state of the samples.

## Normalization I: Within-sample

In order to adjust for the differences in sequencing depth, normalization within samples will be carried out. For this, counts per million (CPM) will be calculated. Moreover, the logarithm with base 2 will be carried out to reduce variability and make the data more suitable for statistical analysis.
```{r within_sample_normalization}
# Calculate the log2 of the CPM and add it to the SummarizedExperiment object 
assays(rnaseq_data_hp)$logCPM <- cpm(dge, log=TRUE, prior.count=0.25)
```

The distribution of the expression of the `logCPM` values is plotted to identify if there are any samples that deviates from the rest.
```{r QA_sample_distribution}
# Representation of the distribution of logCPM
par(mfrow=c(1, 2), mar=c(4, 5, 4, 4))
multidensity(as.list(as.data.frame(assays(rnaseq_data_hp)$logCPM)),
               xlab="log2 CPM", legend=NULL,
               main="", cex.axis=1.2, cex.lab=1.5, las=1)
boxplot(assays(rnaseq_data_hp)$logCPM, col="gray", xlab="Samples",
               ylab=expression(log[2] * "CPM"), cex.axis=1.2, cex.lab=1.5, las=1)
```

Most of the samples follow the same expression levels, except for three samples that appear to present higher levels of expression in the multidensity graph, they present a higher density of high `logCPM` values. It was decided to remove them to avoid possible biases.
```{r removing_samples}
# Calculate densities for each sample
densities <- apply(assays(rnaseq_data_hp)$logCPM, 2, density)

# To identify the samples, as the three have their second local maximum at higher values in the x-axis than the rest, this characteristic will be used to identify them and remove them.

## Function to get the local maximums of a density
get_peaks <- function(dens) {
  peaks <- which(diff(sign(diff(dens$y))) == -2)  # Identify the local maximums
  list(x = dens$x[peaks], y = dens$y[peaks])
}

## Find the local maximums for each sample
sample_peaks <- lapply(densities, get_peaks)

## Create an object with the x-axis coordinates of the second local maximums of each sample
second_peak_locations <- sapply(sample_peaks, function(p) p$x[2])

## Find the three samples with their second local maximum having higher values in their coordinates
second_peak_sorted <- sort(second_peak_locations, decreasing = TRUE)
top_three_outliers <- names(second_peak_sorted)[1:3]
cat("Outliers identified for removal:", top_three_outliers, "\n")

# To corroborate that the samples detected are the correct ones, plot densities for all samples, with the top three outliers highlighted in red
plot(density(assays(rnaseq_data_hp)$logCPM[, top_three_outliers[1]]), col = "red", main = "Density Plot of Samples", xlab = "Expression Level", ylim = range(sapply(densities, function(d) d$y)))
lines(density(assays(rnaseq_data_hp)$logCPM[, top_three_outliers[2]]), col = "red")
lines(density(assays(rnaseq_data_hp)$logCPM[, top_three_outliers[3]]), col = "red")
for (i in 1:ncol(assays(rnaseq_data_hp)$logCPM)) {
  if (!colnames(assays(rnaseq_data_hp)$logCPM)[i] %in% top_three_outliers) {
    lines(density(assays(rnaseq_data_hp)$logCPM[, i]), col = "grey")
  }
}
legend("topright", legend = c("Outliers", "Other Samples"), col = c("red", "grey"), lwd = 2)

# Remove outliers from the SummarizedExperiment and the DGEList objects
rnaseq_data_hp <- rnaseq_data_hp[, !colnames(rnaseq_data_hp) %in% top_three_outliers]
dge <- dge[, !colnames(dge) %in% top_three_outliers]
```

Thanks to the plot, it is confirmed that the three samples detected are the correct ones.

The multidensity plot and the boxplot are remade to ensure that the removal went accordingly.
```{r QA_sample_distribution_II}
# Representation of the distribution of logCPM
par(mfrow=c(1, 2), mar=c(4, 5, 4, 4))
multidensity(as.list(as.data.frame(assays(rnaseq_data_hp)$logCPM)),
               xlab="log2 CPM", legend=NULL,
               main="", cex.axis=1.2, cex.lab=1.5, las=1)
boxplot(assays(rnaseq_data_hp)$logCPM, col="gray", xlab="Samples",
               ylab=expression(log[2] * "CPM"), cex.axis=1.2, cex.lab=1.5, las=1)
```

This time it can be seen that the distribution is more homogeneous, the samples have been correctly removed. 

# Example test

Due to the high difference between the number of tumor samples and healthy samples, for the rest of the data processing and analyses, it has been decided to perform multiple comparisons; in each one, 5 random samples of primary tumor will be compared against the 5 healthy samples. New objects will be created to store the 5 samples classified as `Solid Tissue Normal`, and 5 random samples classified as `Primary solid Tumor`. These new objects will be the ones used from this point forward. It has been decided to create them at this point because the next filtering and normalization steps are dependent on the samples selected.

For the DEA, 1000 groups of 5 Primary solid Tumor samples will be created and 1000 DEAs will be carried out to obtain the differentially expressed genes. But first, an example with one group will be executed to determine possible factors that can affect the analysis.

First, the objects containing 5 tumoral samples and 5 healthy samples are created.
```{r creating_group}
# Obtain the sample metadata
sample_metadata <- colData(rnaseq_data_hp)

################### Obtaining the healthy samples
# Get all the healthy samples IDs
healthy_samples <- rownames(sample_metadata[sample_metadata$definition == "Solid Tissue Normal", ])

################## Obtaining the Primary tumor samples
# Select 5 random sample IDs from "Primary solid Tumor"
set.seed(123)  
primary_tumor_samples <- rownames(sample_metadata[sample_metadata$definition == "Primary solid Tumor", ])
random_primary_tumor_samples <- sample(primary_tumor_samples, 5)

################## Creating the SummarizedExperiment object to be used
# Combine healthy samples IDs and the randomly selected primary tumor sample IDs
selected_samples <- c(healthy_samples, random_primary_tumor_samples)

# Subset the SummarizedExperiment object with the selected samples
rnaseq_data_hp_subset <- rnaseq_data_hp[, colnames(rnaseq_data_hp) %in% selected_samples]

# Make sure that the new object only has 10 samples (10 rows)
dim(colData(rnaseq_data_hp_subset))

################## Creating the DGEList object to be used
# Subset the previous DGEList object
dge_subset <- dge[, colnames(dge) %in% selected_samples]

# Make sure that there are 10 samples (10 columns)
dim(dge_subset)
```

The dimensions of the new SummarizedExperiment and DGEList objects are printed to make sure they have been created accordingly, as 10 samples in total have been selected, the metadata for the samples in the SummarizedExperiment should have 10 rows, and the DGEList object should have 10 columns. It can be seen that this is indeed what happens, therefore, the objects have been created correctly.

## Filtering of lowly-expressed genes

The next step will be filtering out the lowly-expressed genes, as they can introduce artifacts in the analysis. First, a representation of the gene expression is done.
```{r QA_gene_distribution}
# Calculate the average level of expression of each gene
avgexp <- rowMeans(assays(rnaseq_data_hp_subset)$logCPM)

# Plot the average levels of expression 
hist(avgexp, xlab=expression(log[2] * "CPM"), main="", las=1, col="gray")
abline(v=0, col="red", lwd=2)
```

It can be seen that most of the genes are lowly expressed. However, there is a small peak at 5 log2CPM that indicate highly expressed genes. To continue with the analysis, the lowly-expressed genes will be removed. In this case, it has been decided to use a cut-off of 1 log2CPM to remove those genes with lower expression.
```{r LE_genes_removal}
# Create mask using 1 log2CPM as cutoff
mask <- rowMeans(assays(rnaseq_data_hp_subset)$logCPM) > 1

# Create new objects with the filtered genes 
rnaseq_data_hp_subset.filt <- rnaseq_data_hp_subset[mask, ]
dge_subset.filt <- dge_subset[mask, ]
dim(rnaseq_data_hp_subset.filt)
```

A total of 14300 genes that are highly expressed are obtained.

Plotting again the gene expression plot, coloring the 14300 genes in red, the correct selection is confirmed
```{r filtered_genes_representation}
par(mar=c(4, 5, 1, 1))
h <- hist(avgexp, xlab=expression("Expression level (" * log[2] * "CPM)"),
          main="", las=1, col="grey", cex.axis=1.2, cex.lab=1.5)
x <- cut(rowMeans(assays(rnaseq_data_hp_subset.filt)$logCPM), breaks=h$breaks)
lines(h$mids, table(x), type="h", lwd=10, lend=1, col="red")
legend("topright", c("All genes", "Filtered genes"), fill=c("grey", "red"))
```

## Normalization II: between-sample

The next step will be normalizing between samples. The TMM method will be used.
```{r normalization_bet_sample}
dge_subset.filt <- calcNormFactors(dge_subset.filt, method = 'TMM')
```

The raw data is substituted by the normalized data
```{r raw_to_normalized}
# Replace the raw log2 CPM units in the corresponding assay element of the `SummarizedExperiment` object, by the normalized ones.
assays(rnaseq_data_hp_subset.filt)$logCPM <- cpm(dge_subset.filt, log=TRUE,
                              normalized.lib.sizes=TRUE)
```

A boxplot is created to see if there are any significant differences in expression between samples to see if there is any outlier between them
```{r repeat_boxplot}
boxplot(assays(rnaseq_data_hp_subset.filt)$logCPM, col="gray", xlab="Samples",
        ylab=expression(log[2] * "CPM"), las=1)
```

No major difference between the samples are observed.

## QA: MA-plots

To compare, first the individual MA-plots prior to filtering will be plotted. 
```{r MA_plot_before_filter}
# Print them 4 at a time
par(mfrow=c(2, 2), mar=c(4, 5, 1, 1))

# MA-plot generation
for (i in 1:ncol(rnaseq_data_hp_subset)) {
  A <- rowMeans(assays(rnaseq_data_hp_subset)$logCPM)
  M <- assays(rnaseq_data_hp_subset)$logCPM[, i] - A
  smoothScatter(A, M, main=colnames(rnaseq_data_hp_subset)[i], las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

Then, the individual MA-plots after filtering and normalization against the average values will be plotted 
```{r MA_plot_after_filter}
# Print 4 graphs at a time
par(mfrow=c(2, 2), mar=c(4, 5, 1, 1))

# MA-plot generation
for (i in 1:ncol(rnaseq_data_hp_subset.filt)) {
  A <- rowMeans(assays(rnaseq_data_hp_subset.filt)$logCPM)
  M <- assays(rnaseq_data_hp_subset.filt)$logCPM[, i] - A
  smoothScatter(A, M, main=colnames(rnaseq_data_hp_subset.filt)[i], las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

It can be seen that there are some small differences between the individual sample expression trends (red line) and the average expression across all the samples (blue line). In addition, as lowly-expressed genes have been filtered out, the differences observed in lowly-expressed genes in the "before filtering" graphs has been reduced, focus on the genes with higher and more reliable levels of expression. 

Next, a smear plot will be done to compare `Primary solid Tumor` and `Solid Tissue Normal`as groups. As before, a graph before filtering and another after filtering will be carried out.
```{r comparing_by_groups}
# Print the graphs together
par(mfrow=c(2, 1), mar=c(4, 5, 1, 1))

# Assign the type of samples to the DGEList objects
dge_subset$samples$group <- rnaseq_data_hp_subset$definition
dge_subset.filt$samples$group <- rnaseq_data_hp_subset$definition

# Smear plot before filtering
plotSmear(dge_subset, lowess=TRUE, las=1, cex.lab=1.5, cex.axis=1.2)
abline(h=0, col="blue", lwd=2)

# Smear plot after filtering
plotSmear(dge_subset.filt, lowess=TRUE, las=1, cex.lab=1.5, cex.axis=1.2)
abline(h=0, col="blue", lwd=2)

```
In this case, the blue line represents equal expression of the genes between the two types of samples, while the red line portrays the differences in expression between the groups. Therefore, deviations of the red line from the blue line signal that there are genes that may be differentially expressed . Additionally, as this is only an example of one group, it is possible that another group with other samples might give more or less deviation.

## Batch identification and experimental design

In order to detect possible batches that can interfere in the analysis, a hierarchical  clustering is carried out.
```{r batch_identification_hierarchical clustering,  fig.height=5, fig.width=8, dpi=100,}
# Calculate log CPM values with a prior.count of 3 to moderate extreme fold-changes produced by low counts
logCPM <- cpm(dge_subset.filt, log=TRUE, prior.count=3)

# Calculate the distance matrix using Spearman correlation
d <- as.dist(1-cor(logCPM, method="spearman"))

# Perform hierarchical clustering
sampleClustering <- hclust(d)

# To observe gender as a possible batch effect, an object will be created for later use to color each sample's gender
batch <- as.integer(rnaseq_data_hp_subset.filt$gender)
names(batch) <- colnames(rnaseq_data_hp_subset.filt)

# Create a dendrogram object with the hierarchical clustering 
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)

# Create the labels that will be seen in the dendrogram
outcome <- paste(rnaseq_data_hp_subset.filt$shortLetterCode, ' (', rnaseq_data_hp_subset.filt$race, ')', sep="")
names(outcome) <- colnames(rnaseq_data_hp_subset.filt)

# Modify dendrogram labels and color
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)

# Plot the dendrogram
plot(sampleDendrogram, main="Hierarchical clustering of samples",
     cex=0.7)
legend("topright", levels(rnaseq_data_hp_subset.filt$gender),
       fill=seq_len(nlevels(rnaseq_data_hp_subset.filt$gender)))
```
Thanks to the dendrogram, it can be seen that the samples previously observed to have an `NA` value for race are those in the normal tissue samples. Under further inspection to `colData(rnaseq_data_hp_subset.filt)`,  all normal tissue samples are also unknown for gender. Therefore, neither race or gender can be applied as batch effects. Despite this, it can be see that the two types of samples are correctly differentiated, giving an idea that there may indeed be some differences. 

Another way to determine batches is through a Multidimensional Scaling (MDS) plot.
```{r batch_identificatio_nmps_graph}
# Creating the labels of the samples
outcome <- paste(rnaseq_data_hp_subset.filt$shortLetterCode, ' (', rnaseq_data_hp_subset.filt$race, ')', sep="")
names(outcome) <- colnames(rnaseq_data_hp_subset.filt)

# Creating the MDS plot
plotMDS(dge_subset.filt, labels=outcome, col=batch)
legend("right", levels(rnaseq_data_hp_subset.filt$gender),
       fill=seq_len(nlevels(rnaseq_data_hp_subset.filt$gender)), inset=0.05)
```
It can see seen that even between TP samples, there is a high variability, but that they are all separated from the NT samples, reinforcing the idea of existing differences in expression between the tumor and healthy samples.

In conclusion, as all 5 healthy samples miss data for both race and gender, so their effect can't be accounted for in the following analysis. Age was also contemplated as a possible confounding effect, but as race and gender, no data is available in healthy samples.

## Differential expression analysis

In order to start the DEA; first the levels of the target variable are modified to make the healthy samples as references, this way, all results will be of the tumor samples compared to the healthy samples. Moreover, the model for the analysis is created, as stated before, no confounding effect will be taken into account, as the healthy samples lack enough data to be able to do it.
```{r define_the_reference}
# Eliminating non-important or repeated variables to ease the analysis
colData(rnaseq_data_hp_subset.filt) <- as(colData(rnaseq_data_hp_subset.filt), "data.frame") %>%
  select(barcode, patient, sample, definition, intermediate_dimension, shortest_dimension, longest_dimension, 
         age_at_diagnosis, race, gender, ethnicity, vital_status, age_at_index, 
         paper_Tissue.source.site, days_to_death, paper_Original.Subtype) %>%
  as("DFrame")

# Define the reference
rnaseq_data_hp_subset.filt$definition <- relevel(rnaseq_data_hp_subset.filt$definition, ref="Solid Tissue Normal")

# Creating the model for the analysis
mod <- model.matrix(~ definition, data=colData(rnaseq_data_hp_subset.filt))
head(mod, 15)
```

Although some possible confounding effects were tested for, there might be others that are being missed, hidden batch effects. To avoid this, a Surrogate Variable Analysis (SVA) will be carried out.
```{r SVA}
# Creating a model to compare the previously created against
mod0 <- model.matrix(~ 1, colData(rnaseq_data_hp_subset.filt))

# Carry out the SVA analysis
sv <- sva(assays(rnaseq_data_hp_subset.filt)$logCPM, mod=mod, mod0=mod0)
```

Thanks to the results fo the analysis, 3 significant surrogate variables are obtained.

In order to see their significance, a Singular Value Decomposition (SVD) is done to see the amount of contribution to the variance by each surrogate variable
```{r SVA_SVD}
# Perform SVD on the logCPM values
svd_result <- svd(scale(assays(rnaseq_data_hp_subset.filt)$logCPM))
eigenvalues <- svd_result$d^2

# Plot eigenvalues
plot(eigenvalues, type = "b", xlab = "Component", ylab = "Eigenvalue", main = "SVD Eigenvalues")

```
As indicated by the SVA results, the three surrogate variables accounts for much of the variance unrelated to the "Tumor vs Healthy" differences, helping to mitigate the noise and potential confounding effects. 

The model is modified to take the surrogate variables into account. Then the DEA is carried out with `voomLmFit`from the package `EdgeR` [@edgeR], and with `eBayes`from the package `limma` [@limma]
```{r t-statistic}
# Addition of the SVA surregate variables
mod <- cbind(mod, sv$sv)

# Carry out the Differential Expression Analysis
fit <- voomLmFit(dge_subset.filt, mod, block= rnaseq_data_hp_subset$patient)
fit <- eBayes(fit)
```

The results of the DEA can be found in the object `fit`.

In `fit`, the genes do not appear as their symbols, to make it more understandable, the Ensembl code [@Ensembl2024] will be changed by the genes' symbols. 
```{r gene_data}
genesmd <- data.frame(chr=as.character(seqnames(rowRanges(rnaseq_data_hp_subset.filt))),
                        symbol=rowData(rnaseq_data_hp_subset.filt)[, 7], description=rowData(rnaseq_data_hp_subset.filt)[, 6],
                      EntrezID = rownames(rnaseq_data_hp_subset.filt), stringsAsFactors=FALSE)
fit$genes <- genesmd
```

Before proceeding, correction for multiple testing is necessary, for it, the function `topTable()` is used. This function uses Benjamini-Hochberg FDR (Flase Discovery Rate) as method for correction.
Moreover, the amount of genes that are overexpressed, underexpressed or stays the same in healthy samples (intercept) will also be printed.
```{r multiple_test_correction}
# Multiple testing correction
tt <- topTable(fit, coef=2, n=Inf)

# Genes divided by change in expression
res <- decideTests(fit, p.value=0.1)
print(summary(res))
```

A plot with the distribution of the P.values for each gene is created.
```{r pvalues}
# Create a histogram with the P.values
h <- hist(tt$P.Value, xlab="Raw P-values", main="",
          las=1)
```
It can be seen that many genes have low p-values, signaling to differences in expression.

A volcano plot is also created to see the distribution of the differentially expressed genes, either underexpressed or overexpressed.
```{r volcano}
# Create the volcano plot
volcanoplot(fit, coef=2, highlight=10, names=fit$genes$symbol,
            main="", las = 1)
```
Although many genes appear to be underexpressed in tumor samples, like DNM1, PACSIN1, SYP, SYT1... there is one overexpressed in the top differentially expressed genes, BIRC5.

In addition, an MA-plot will also be created to also represent the differentially expressed genes distribution.
```{r MA_plots_after}
# Obtaining the name of the top 10 DEG
top10 <- order(fit$lods[, 2], decreasing=TRUE)[1:10]

# Filter for genes with less than a 0.1 adjusted P.value
DEgenes <- rownames(tt)[tt$adj.P.Val < 0.1]

# Createing the MA-plot
limma::plotMA(fit, coef=2, status=rownames(fit$lods) %in% DEgenes, legend=FALSE,
              main="", hl.pch=46, hl.cex=4, bg.pch=46, bg.cex=3, las =1)
text(fit$Amean[top10], fit$coef[top10, 2], fit$genes$symbol[top10], cex=0.5, pos=4)
```

To have the complete list of differentially expressed genes, a final filter is undergone, only those that after the correction have an adjusted P.value of less than 0.1 will be kept.
```{r DGE_list}
DEGtable <- tt %>% filter(adj.P.Val < 0.1) %>% arrange(P.Value)
rownames(DEGtable) <- 1:nrow(DEGtable)
```

However, as previously stated, this example was only to determine which factors to take into account for the rest of the groups, for example: using the sva data, but not use variables such as race, gender or age due to lack of information in the healthy samples. 

# Carrying out the 1000 DEAs

In order to obtain results using all the data available, multiple groups of 5 primary tumor samples will be created, and the same path will be followed (without the graphics, to optimize performance), obtaining the list of all comparisons.
```{r loop}
# Defining the objects where the results will be stored
results<- data.frame(assay=character(), symbol=character(), logFC=numeric(), adjPvalue=numeric())
samples_selected <- vector("list", 1000)

# Carry out the multiple DEAs
for (i in 1:1000){
  # Counter in order to know in which comparison it is
  print(i)
  
  # Randomly select 5 samples from "Primary solid Tumor"
  random_primary_tumor_samples <- sample(primary_tumor_samples, 5)
  samples_selected[[i]]<- random_primary_tumor_samples
  
  # Combine healthy samples and the randomly selected primary tumor samples.
  selected_samples <- c(healthy_samples, random_primary_tumor_samples)

  # Subset the SummarizedExperiment object with the selected samples
  rnaseq_data_hp_subset <- rnaseq_data_hp[, colnames(rnaseq_data_hp) %in% selected_samples]

  # Subset the previous DGEList object
  dge_subset <- dge[, colnames(dge) %in% selected_samples]
  
  # Filtering lowly expressed genes
  mask <- rowMeans(assays(rnaseq_data_hp_subset)$logCPM) > 1
  rnaseq_data_hp_subset.filt <- rnaseq_data_hp_subset[mask, ]
  dge_subset.filt <- dge_subset[mask, ]
  
  # Between-sample normalization
  dge_subset.filt <- calcNormFactors(dge_subset.filt, method = 'TMM')
  assays(rnaseq_data_hp_subset.filt)$logCPM <- cpm(dge_subset.filt, log=TRUE,
                              normalized.lib.sizes=TRUE)
  
  # Differential expression analysis
  colData(rnaseq_data_hp_subset.filt) <- as(colData(rnaseq_data_hp_subset.filt), "data.frame") %>%
  select(barcode, patient, sample, definition, intermediate_dimension, shortest_dimension, longest_dimension, 
         age_at_diagnosis, race, gender, ethnicity, vital_status, age_at_index, 
         paper_Tissue.source.site, days_to_death, paper_Original.Subtype) %>%
  as("DFrame")
  rnaseq_data_hp_subset.filt$definition <- relevel(rnaseq_data_hp_subset.filt$definition, ref="Solid Tissue Normal")
  mod <- model.matrix(~ definition, data=colData(rnaseq_data_hp_subset.filt))
  mod0 <- model.matrix(~ 1, colData(rnaseq_data_hp_subset.filt))
  sv <- sva(assays(rnaseq_data_hp_subset.filt)$logCPM, mod=mod, mod0=mod0)
  mod <- cbind(mod, sv$sv)
  fit <- voomLmFit(dge_subset.filt, mod, block = rnaseq_data_hp_subset$patient)
  fit <- eBayes(fit)
  genesmd <- data.frame(chr=as.character(seqnames(rowRanges(rnaseq_data_hp_subset.filt))),
                        symbol=rowData(rnaseq_data_hp_subset.filt)[, 7], description=rowData(rnaseq_data_hp_subset.filt)[, 6],
                      EntrezID = rownames(rnaseq_data_hp_subset.filt), stringsAsFactors=FALSE)
  fit$genes <- genesmd
  tt <- topTable(fit, coef=2, n=Inf)
  DEGtable <- tt %>% filter(adj.P.Val < 0.1) %>% arrange(P.Value)
  rownames(DEGtable) <- 1:nrow(DEGtable)
  
  # Obtaining the important information from the results
 print("adding results")
 new_entry<-cbind(i, DEGtable %>% select(symbol, logFC, adj.P.Val))
 colnames(new_entry)<-colnames(results)
 results<-rbind(results, new_entry)
}
```

# Analysing the results

After obtaining the list with all the differentially expressed genes in `results`, a count table is created to see how many times each of the wanted genes for the study appears in the results of the analyses.
```{r count_matrix_creation}
# Filtering for the wanted genes 
study_genes <- c("CDH1","CDH2","L1CAM","EPCAM", "EGFR", "NANOG", "ALDH1A1", "OCT4", "ABCG2", "HRAS", "KRAS","NRAS", "GAPDH", "PIK3CB")
results_filtered <- results %>% filter(symbol %in% study_genes)

# Creating the count table
gene_counts <- table(results_filtered$symbol)

# Convert the table to a data frame
gene_count_df <- as.data.frame(gene_counts)
colnames(gene_count_df) <- c("Gene", "Count")
rownames(gene_count_df) <- gene_count_df[,1]
```

Revising the distribution of the results might give an insight of them.
```{r DEG_distribution}
# A data frame with the possible ranges of number of counts
bins <- data.frame(Count_Bin = factor(
  levels(cut(0, breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE)),
  levels = unique(cut(seq(0, 1000, by = 1), breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE))
))

# Object that will divide the genes in groups depending on the number of DEAs they ahve appeared as a DEG
gene_count_summary <- gene_count_df %>%
  mutate(Count_Bin = cut(Count, breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE)) %>%
  group_by(Count_Bin) %>%
  summarize(Num_Genes = n()) %>%
  right_join(bins, by = "Count_Bin") %>%
  replace_na(list(Num_Genes = 0))

# Plot the distribution
ggplot(gene_count_summary, aes(x = Count_Bin, y = Num_Genes)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
    title = "Distribution of Gene Counts by Range",
    x = "Count Range",
    y = "Number of Genes"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

It can be seen that six of them have appeared as DEG in between 900 and 1000 DEAs. Despite this, even though multiple testing correction has been taken into account independently in each DEA, as 1000 analyses have been performed, another multiple testing correction must be applied to take into account the number of analyses carried out.  
```{r FDR}
# Creation of the object that will store the results after multiple testing correction
results_fdr <- matrix(nrow=0, ncol=4)

# Obtaining the newly adjusted P.values with FDR modifying the adjusted P.values obtained from the DEAs
for (i in 1:nrow(gene_count_df)){
  gene_pvalues<- results_filtered %>% filter(symbol == gene_count_df[i, "Gene"])
  adjusted_pvalues <- p.adjust(gene_pvalues$adjPvalue, method = "fdr", n=1000)
  copy_data <- results_filtered %>% filter(symbol==gene_count_df[i, "Gene"])
  copy_data$adjPvalue <- adjusted_pvalues
  results_fdr<- rbind(results_fdr, copy_data)
}

# Filter the adjusted P.values using a cutoff of  0.1
results_fdr <- results_fdr %>% filter(adjPvalue < 0.1)

# Count the frequency of each gene across all comparisons
gene_counts <- table(results_fdr$symbol)

# Convert the table to a data frame
gene_count_df_fdr <- as.data.frame(gene_counts)
colnames(gene_count_df_fdr) <- c("Gene", "Count")
rownames(gene_count_df_fdr) <- gene_count_df_fdr[,1]
```

Now, the object `gene_count_df_fdr` carries the number of times each gene has appeared as a DEG after eliminating the possible false positives. The distribution is plotted again.
```{r distribution_II}
# A data frame with the possible ranges of number of counts
bins <- data.frame(Count_Bin = factor(
  levels(cut(0, breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE)),
  levels = unique(cut(seq(0, 1000, by = 1), breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE))
))

# Object that will divide the genes in groups depending on the number of DEAs they have appeared as a DEG
gene_count_summary <- gene_count_df_fdr %>%
  mutate(Count_Bin = cut(Count, breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE)) %>%
  group_by(Count_Bin) %>%
  summarize(Num_Genes = n()) %>%
  right_join(bins, by = "Count_Bin") %>%
  replace_na(list(Num_Genes = 0))

# Plot the distribution
ggplot(gene_count_summary, aes(x = Count_Bin, y = Num_Genes)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
    title = "Distribution of Gene Counts by Range",
    x = "Count Range",
    y = "Number of Genes"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
It can be seen that, although the six genes that appeared in the range between 900 and 1000 remain in the same range, other genes with lower number of appearances as DEG have move from range. for example, now the range between 700-800 is empty, while now there is a gene in the range between 400-500.

The object `gene_count_df_fdr` only says how many times each gene has appeared as differentially expressed, whether they are overexpressed or underexpressed in tumor samples with respect to healthy samples is still unknown. For this, the object `results_fdr` will be used, as it holds the fold-change of each gene in each DEA. Whether the fold-change is positive or negative will tell if the gene is overexpressed or underexpressed, respectively.  
```{r expression}
# Object where the number of times each gene appears as overexpressed or underexpressed will be stored
expression_matrix<-matrix(ncol = 2, nrow = 0)

# Loop obtaining the values
for (i in 1:nrow(gene_count_df_fdr)){
  overexpressed<- nrow(results_fdr %>% filter(symbol==gene_count_df_fdr[i,"Gene"] & logFC>0))
  underexpressed<- nrow(results_fdr %>% filter(symbol==gene_count_df_fdr[i,"Gene"] & logFC<0))
  temp_matrix<-matrix(c(overexpressed, underexpressed), ncol=2, nrow=1)
  expression_matrix<- rbind(expression_matrix, temp_matrix)
}

# Adding the values to the count table
gene_count_df_fdr<-cbind(gene_count_df_fdr,expression_matrix)
colnames(gene_count_df_fdr) <- c("Gene", "Count", "overexpressed", "underexpressed")
```

The percentage of the times each gene has come up as a DEG will be obtained and added to the count table and plotted.
```{r percentage}
# Obtaining the percentages
gene_count_df_fdr <- gene_count_df_fdr %>% mutate(percentage=((Count/1000)*100))

# Plot the percentages
ggplot(gene_count_df_fdr, aes(x = Gene, y = percentage)) +
  geom_bar(stat = "identity", position = "identity") +
  scale_fill_manual(values = c("black")) +
  labs(y = "Percantage of positive analyses", x = "Gene") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```
The genes that are in the range of apprearance between 900-1000 are: _PIK3CB_ (1000), _L1CAM_ (999), _EGFR_ (997), _NRAS_ (990), _KRAS_ (976) and _HRAS_ (945). Following these genes, the rest had counts of: _CDH2_ (825), _GAPDH_ (813), _ALDH1A1_ (678), _CDH1_ (437), _ABCG2_ (215), _EPCAM_ (52). It can be seen that, from the 14 genes filtered for, two have not appeared as DEG in any of the DEAs: _OCT4_ and _NANOG_ .

To know if all the times they appear as DEG, the change has the same direction, alas, to see if in all cases, the results give underexpression or overexpression, a plot will be created with the count for overexpression and underexpression for each gene. 
```{r image_2}
# Select the important variables and modify the table to ease the plotting and the visualizing 
data_long <- gene_count_df_fdr %>%
  select(Gene, overexpressed, underexpressed) %>%  
  pivot_longer(cols = c(overexpressed, underexpressed), 
               names_to = "ExpressionType", 
               values_to = "Count") %>%
  mutate(Count= ifelse(ExpressionType == "underexpressed", -Count, Count))

# Create the side-by-side bar plot
ggplot(data_long, aes(x = Gene, y = Count, fill = ExpressionType)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  scale_fill_manual(values = c("overexpressed" = "blue", "underexpressed" = "red")) +
  labs(x = "Gene", y = "Count", title = "Overexpressed vs Underexpressed Counts for Each Gene") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
It can be seen that the genes _ABCG2_, _CDH2_, _EGFR_, _GAPDH_ and _NRAS_ are mainly overexpressed, while the genes _ALDH1A1_, _CDH1_, _EPCAM_, _HRAS_, _KRAS_, _L1CAM_, _PIK3CB_ are underexpressed. Although it can also be seen that two genes also present some analyses in which they appear to ahve the contrary change of expression: _ABCG2_ (mainly overexpressed, some underexpression exceptions) and _CDH1_ (mainly underexpressed, some overexpression exceptions). Although multiple test correction has been applied, an hypothesis for these exceptions may be that they are false positives.

The next step is to see the magnitude of the changes in expression for the target genes.
```{r average_logFC}
# Object where the average logFC changes
avg_logFC <- matrix(ncol=1, nrow=0)
colnames(avg_logFC)<- c("average_logFC")

# Obtaining the average logFC 
for (i in 1: nrow(gene_count_df_fdr)){
  avg_logFC<-rbind(avg_logFC, mean((results_filtered %>% filter(symbol==gene_count_df[i, "Gene"]))$logFC))
}

# Adding the values to the count matrix
gene_count_df_fdr<-cbind(gene_count_df_fdr, avg_logFC)

# Plotting the average logFC
ggplot(gene_count_df_fdr, aes(x = Gene, y = average_logFC, fill = average_logFC > 0)) +
  geom_bar(stat = "identity", position = "identity") +
  scale_fill_manual(values = c("TRUE"= "blue", "FALSE"="red")) +
  labs(y = "average logFC", x = "Gene") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

From the 12 remaining genes, 6 of them show absolute changes higher than one: _L1CAM_ (-4.2733309), _EGFR_ (4.1143263), _EPCAM_ (-2.3932883), _ALDH1A1_(-1.3867941), _CDH1_(-1.3569861) and _PIK3CB_(-1.3308456).

# Exporting the results

Finally, the count table with the additional information that have been calculated is exported:
```{r export_data}
write.xlsx(gene_count_df_fdr, "results_comparison_healthy_primary.xlsx")
```