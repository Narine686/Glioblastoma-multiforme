---
title: "workflow_PT_RT"
author: "Narine Fischer Albiol"
date: "2024-10-29"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

The following workflow uses R language [@rsoftware] to carry out a Differential Expression Analysis (DEA) using data obtained from the Genomic Data Commons Data Portal [@gdcportal]. RNA-seq expression data in primary tumor samples of patients with glioblastoma multiforme (GM) was analyzed against recurrent tumor samples. From the differentially expressed genes (DEG), the desired ones (_CDH1_, _CDH2_, _L1CAM_, _EPCAM_, _EGFR_, _NANOG_, _ALDH1A1_, _OCT4_, _ABCG2_, _HRAS_, _KRAS_, _NRAS_, _GAPDH_, _PIK3CB_) were filtered to see how their expression changes between the two types of samples.

## Needed libraries

The libraries used come from both CRAN [@cran] and Bioconductor [@bioconductor]. 
```{r libraries}
library(TCGAbiolinks)
library(edgeR)
library(geneplotter)
library(limma)
library(sva)
library(dplyr)
library(ggplot2)
library(tidyr)
library(rlist)
```

## Data download

## Data download

As previously stated, the data will be obtained from the Genomic Data Commons data portal [@gdcportal], a repository with data from projects studying cancer. In this case, the data will be downloaded from the project TCGA-GBM, with data specific to glioblastoma multiforme. Therefore, The results published here are in whole or part based upon data generated by The Cancer Genome Atlas managed by the NCI and NHGRI. Information about TCGA can be found at http://cancergenome.nih.gov .The RNA-seq data obtained during this project will be the one selected. For this step, the package `TCGAbiolinks` will be used [@TCGAbiolinks].
```{r data_download}

# Query for RNA-Seq data from TCGA-GBM project
query_rnaseq <- GDCquery(
  project = "TCGA-GBM",
  data.category = "Transcriptome Profiling",
  data.type = "Gene Expression Quantification",
  experimental.strategy = "RNA-Seq",
  access = "open"
)

# Download the RNA-Seq data
GDCdownload(query_rnaseq, method = "client")

# Prepare RNA-Seq data for analysis, creating a SummarizedExperiment object, in case the data had already been downloaded and the previous steps are not necessary.
rnaseq_data <- GDCprepare(query_rnaseq)
```

In the `rnaseq_data` object, there are 60660 genes by 176 samples. Looking at the data of the columns (samples) (`colData(rnaseq_data)`), it can be seen in `definition` that samples pertain to three different groups: Primary solid Tumor (158), Recurrent Solid Tumor (13), and Solid Tissue Normal (5). 
It can be seen that the number of Primary solid Tumor samples is higher than the number of Recurrent Solid Tumor samples.
 

# Quality assessment and processing of data

## Observation of possible confounding variables

As the intent of this workflow is to compare primary tumor samples against recurrent tumor samples, the `rnaseq_data` will be filtered to only obtain these two types of samples. As there are some patients with a sample classified as `Primary solid Tumor` and another sample classified as `Recurrent Solid Tumor`, it has been decided to eliminate the `Primary solid Tumor`samples to ease the analyses. Moreover a DGELISt object will be created for further analyses. 
```{r filter_rnsaseq_data}
# Filter for healthy and primary tumor samples
rnaseq_data_pr <- rnaseq_data[, colData(rnaseq_data)$definition %in% c("Primary solid Tumor", "Recurrent Solid Tumor")]

# Erase primary sample tumor samples from patients that also present a recurrent tumor sample
patient_numbers<- table(rnaseq_data_pr$patient)
repeated_patients <- names(patient_numbers[patient_numbers > 1])
samples <- as.data.frame(colData(rnaseq_data_pr))
samples_to_eliminate<- samples %>% filter((patient %in% repeated_patients[repeated_patients != "TCGA-06-0156"]) & (shortLetterCode == "TP")) %>% select(barcode)
rnaseq_data_pr <- rnaseq_data_pr[, !colnames(rnaseq_data_pr) %in% c(samples_to_eliminate[["barcode"]])]

# Create a DGEList object for the analysis
dge <- DGEList(counts=assays(rnaseq_data_pr)$unstranded, genes=rowData(rnaseq_data_pr),
                 samples=colData(rnaseq_data_pr))
```

The sequencing depth per sample will be mapped and colored according to a variable that is believed that might cause a confounding effect. The first variable to be observed is `gender`. The aim is to see if there is any difference in sequencing depth due to gender, this should be done with any variable that wants to be investigated. A graph with the ordered sequencing depths and colored by `gender` is created.
```{r quality_assessment_gender}
# Quality assessment: depth sequencing - gender
ord <- order(dge$sample$lib.size)
rnaseq_data_pr$gender<-factor(rnaseq_data_pr$gender)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("red", "blue")[rnaseq_data_pr$gender[ord]])
legend("topleft", c("female", "male"), fill=c("red", "blue"), inset=0.01)
```

There are some considerable differences in sequencing depth per sample, ranging from 7 to 80 million reads; therefore, normalization within samples is needed. Furthermore, it appears that gender could act as a confounding factor in subsequent analyses, as many samples classified as "female" cluster at the low coverage end of the graph, this possible confounding effect will be taken into account during the Differential Expression Analysis (DEA). Moreover, it is visible that a sample does not present a value assigned for `gender`. 

The next variable to be assessed is `race`.
```{r quality_assessment_race}
# Quality assessment: depth sequencing - race. A graph with the ordered sequencing depths and colored by race is created.
rnaseq_data_pr$race<-factor(rnaseq_data_pr$race)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("green", "yellow", "#ED3EF7", "#FF885B")[rnaseq_data_pr$race[ord]])
legend("topleft", c("asian", "black or african american", "not reported", "white"), fill=c("green", "yellow", "#ED3EF7", "#FF885B"), inset=0.01)
```

It can be seen that most of the sample come from a white population. It is not possible to actually discern if any confounding effect may be affecting our data due to differences in sequencing depth by `race`. Therefore, it has been decided to take the variable into account for the DEA. As with `gender`, there are some samples without a value assigned. 

It will also be seen if there is any distinction in sequencing depth depending on the target variable, `definition`.
```{r quality_assessment_definition}
# Quality assessment: depth sequencing - definition. A graph with the ordered sequencing depths and colored by definition is created
rnaseq_data_pr$definition<-factor(rnaseq_data_pr$definition)
barplot(dge$sample$lib.size[ord]/1e6, las=1, ylab="Millions of reads",
        xlab="Samples", col=c("brown", "lightpink")[rnaseq_data_pr$definition[ord]])
legend("topleft", c("Primary solid Tumor", "Recurrent solid Tumor"), fill=c("brown", "lightpink"), inset=0.01)
```

As with `race`, due to the low amount of samples for `Recurrent Solid Tumor`, it can not be discerned if there is any relation between sequencing depth and the cancer state of the samples.

Moreover, with a look at `colData(rnaseq_data_pr)`, it can be seen that the sample whose gender and race values are missing is the same: TCGA-28-2510-01A-01R-1850-01 . As it is the only sample with this characteristics, it has been decided to remove it from the analyses.

```{r remove_sample}
rnaseq_data_pr <- rnaseq_data_pr[, !colnames(rnaseq_data_pr) %in% c("TCGA-28-2510-01A-01R-1850-01")]
dge <- dge[, !colnames(dge) %in% c("TCGA-28-2510-01A-01R-1850-01")]
```

## Within-sample normalization

In order to adjust for the differences in sequencing depth, normalization within samples will be carried out. For this, counts per million (cpm) will be calculated. Moreover, the logarithm with base 2 will be carried out to reduce variability and make the data more suitable for statistical analysis.
```{r within_sample_normalization}
# Create a new object with the log2 of the CPM and add it to the SummarizedExperiment object 
assays(rnaseq_data_pr)$logCPM <- cpm(dge, log=TRUE, prior.count=0.25)
```

The distribution of the expression of the logCPM values is plotted to identify if there are any samples that deviates from the rest.
```{r QA_sample_distribution}
# Representation of the distribution of logCPM
par(mfrow=c(1, 2), mar=c(4, 5, 4, 4))
multidensity(as.list(as.data.frame(assays(rnaseq_data_pr)$logCPM)),
               xlab="log2 CPM", legend=NULL,
               main="", cex.axis=1.2, cex.lab=1.5, las=1)
boxplot(assays(rnaseq_data_pr)$logCPM, col="gray", xlab="Samples",
               ylab=expression(log[2] * "CPM"), cex.axis=1.2, cex.lab=1.5, las=1)
```

Most of the samples follow the same expression levels, except for three samples that appear to present higher levels of expression in the multidensity graph, they present a higher density of high `logCPM` values. It was decided to remove them to avoid possible biases.
```{r removing_samples}
# Calculate densities for each sample
densities <- apply(assays(rnaseq_data_pr)$logCPM, 2, density)

# To identify the samples, as the three have their second local maximum at higher values in the x-axis than the rest, this characteristic will be used to identify them and remove them.

## Function to get the local maximums of a density
get_peaks <- function(dens) {
  peaks <- which(diff(sign(diff(dens$y))) == -2)  # Identify the local maximums
  list(x = dens$x[peaks], y = dens$y[peaks])
}

## Find the local maximums for each sample
sample_peaks <- lapply(densities, get_peaks)

## Create an object with the x-axis coordinates of the second local maximums of each sample
second_peak_locations <- sapply(sample_peaks, function(p) p$x[2])

## Find the three samples with their second local maximum having higher values in their coordinates
second_peak_sorted <- sort(second_peak_locations, decreasing = TRUE)
top_three_outliers <- names(second_peak_sorted)[1:3]
cat("Outliers identified for removal:", top_three_outliers, "\n")

# To corroborate that the samples detected are the correct ones, plot densities for all samples, with the top three outliers highlighted in red
plot(density(assays(rnaseq_data_pr)$logCPM[, top_three_outliers[1]]), col = "red", main = "Density Plot of Samples", xlab = "Expression Level", ylim = range(sapply(densities, function(d) d$y)))
lines(density(assays(rnaseq_data_pr)$logCPM[, top_three_outliers[2]]), col = "red")
lines(density(assays(rnaseq_data_pr)$logCPM[, top_three_outliers[3]]), col = "red")
for (i in 1:ncol(assays(rnaseq_data_pr)$logCPM)) {
  if (!colnames(assays(rnaseq_data_pr)$logCPM)[i] %in% top_three_outliers) {
    lines(density(assays(rnaseq_data_pr)$logCPM[, i]), col = "grey")
  }
}
legend("topright", legend = c("Outliers", "Other Samples"), col = c("red", "grey"), lwd = 2)

# Remove outliers from the SummarizedExperiment and the DGEList objects
rnaseq_data_pr <- rnaseq_data_pr[, !colnames(rnaseq_data_pr) %in% top_three_outliers]
dge <- dge[, !colnames(dge) %in% top_three_outliers]
```

Thanks to the plot, it is confirmed that the three samples being removed are the correct ones.

The multidensity plot and the boxplot are remade to ensure that the removal went accordingly.

```{r QA_sample_distribution_II}
# Representation of the distribution of logCPM
par(mfrow=c(1, 2), mar=c(4, 5, 4, 4))
multidensity(as.list(as.data.frame(assays(rnaseq_data_pr)$logCPM)),
               xlab="log2 CPM", legend=NULL,
               main="", cex.axis=1.2, cex.lab=1.5, las=1)
boxplot(assays(rnaseq_data_pr)$logCPM, col="gray", xlab="Samples",
               ylab=expression(log[2] * "CPM"), cex.axis=1.2, cex.lab=1.5, las=1)
```

This time it can be seen that the distribution is more homogeneous, the samples have been correctly removed. 

## Example

Due to the high difference between the number of primary tumor samples and recurrent tumor samples, for the rest of the data processing and analyses, it has been decided to perform multiple comparisons; in each one, 13 random samples of primary tumor will be compared against the 13 recurrent tumor samples. New objects will be created to store the 13 samples classified as `Recurrent Solid Tumor`, and 5 random samples classified as `Primary solid Tumor`. These new objects will be the ones used from this point forward. It has been decided to create them at this point because the next filtering and normalization steps are dependent on the samples selected.

For the DEA, 1000 groups of 13 Primary solid Tumor samples will be created and 1000 DEAs will be carried out to obtain the differentially expressed genes. But first, an example with one group will be executed to determine possible factors that can affect the analysis.

First, the objects containing 13 primary tumor samples and 13 recurrent tumor samples are created.
```{r creating_group}
# Obtain the sample metadata
sample_metadata <- colData(rnaseq_data_pr)

################### Obtaining the recurrent tumor samples
# Get all the recurrent tumor samples
r_tumor_samples <- rownames(sample_metadata[sample_metadata$definition == "Recurrent Solid Tumor", ])

################## Obtaining the Primary tumor samples
# Select 5 random samples from "Primary solid Tumor"
set.seed(123)  
primary_tumor_samples <- rownames(sample_metadata[sample_metadata$definition == "Primary solid Tumor", ])
random_primary_tumor_samples <- sample(primary_tumor_samples, 13)

################## Creating the SummarizedExperiment object to be used
# Combine recurrent tumor samples and the randomly selected primary tumor samples
selected_samples <- c(r_tumor_samples, random_primary_tumor_samples)

# Subset the SummarizedExperiment object with the selected samples
rnaseq_data_pr_subset <- rnaseq_data_pr[, colnames(rnaseq_data_pr) %in% selected_samples]

# Make sure that the new object only has 26 samples (26 rows)
dim(colData(rnaseq_data_pr_subset))

################## Creating the DGEList object to be used
# Subset the previous DGEList object
dge_subset <- dge[, colnames(dge) %in% selected_samples]

# Make sure that there are 26 samples (26 columns)
dim(dge_subset)
```

The dimensions of the new SummarizedExperiment and DGEList objects are printed to make sure they have been created accordingly, as 26 samples in total have been selected, the metadata for the samples in the SummarizedExperiment should have 26 rows, and the DGEList object should have 26 columns. It can be seen that this is indeed what happens, therefore, the objects have been created correctly.

## Filtering of lowly-expressed genes

The next step will be filtering out the lowly-expressed genes, as they can introduce artifacts in the analysis. First, a representation of the gene expression is done.
```{r QA_gene_distribution}
# Calculate the average level of expression of each gene
avgexp <- rowMeans(assays(rnaseq_data_pr_subset)$logCPM)

# Plot the average levels of expression 
hist(avgexp, xlab=expression(log[2] * "CPM"), main="", las=1, col="gray")
abline(v=0, col="red", lwd=2)
```

It can be seen that most of the genes are lowly expressed. However, there is a small peak at 5 log2CPM that indicate highly expressed genes. To continue with the analysis, the lowly-expressed genes will be removed. In this case, it has been decided to use a cut-off of 1 log2CPM to remove those genes with lower expression.
```{r LE_genes_removal}
# Create mask using 1 log2CPM as cutoff
mask <- rowMeans(assays(rnaseq_data_pr_subset)$logCPM) > 1

# Create new objects with the filtered genes 
rnaseq_data_pr_subset.filt <- rnaseq_data_pr_subset[mask, ]
dge_subset.filt <- dge_subset[mask, ]
dim(rnaseq_data_pr_subset.filt)
```
A total of 14262 genes that are highly expressed are obtained.

Plotting again the gene expression plot, coloring the 14262 genes in red, the correct selection is confirmed
```{r filtered_genes_representation}
par(mar=c(4, 5, 1, 1))
h <- hist(avgexp, xlab=expression("Expression level (" * log[2] * "CPM)"),
          main="", las=1, col="grey", cex.axis=1.2, cex.lab=1.5)
x <- cut(rowMeans(assays(rnaseq_data_pr_subset.filt)$logCPM), breaks=h$breaks)
lines(h$mids, table(x), type="h", lwd=10, lend=1, col="red")
legend("topright", c("All genes", "Filtered genes"), fill=c("grey", "red"))
```

## Normalization II: between-sample

The next step will be normalizing between samples. The TMM method will be used.
```{r normalization_bet_sample}
dge_subset.filt <- calcNormFactors(dge_subset.filt, method = 'TMM')
```

The raw data is substituted by the normalized data
```{r raw_to_normalized}
#replace the raw log2 CPM units in the corresponding assay element of the `SummarizedExperiment` object, by the normalized ones.
assays(rnaseq_data_pr_subset.filt)$logCPM <- cpm(dge_subset.filt, log=TRUE,
                              normalized.lib.sizes=TRUE)
```

A boxplot is created to see if there are any significant differences in expression between samples to see if there is any outlier between them
```{r repeat_boxplot}
boxplot(assays(rnaseq_data_pr_subset.filt)$logCPM, col="gray", xlab="Samples",
        ylab=expression(log[2] * "CPM"), las=1)
```
No major difference between the samples are observed.

## QA: MA-plots

To compare, first the individual MA-plots prior to filtering will be filtered.
```{r MA_plot_before_filter}
# Print them 4 at a time
par(mfrow=c(2, 2), mar=c(4, 5, 1, 1))

# MA-plot generation
for (i in 1:ncol(rnaseq_data_pr_subset)) {
  A <- rowMeans(assays(rnaseq_data_pr_subset)$logCPM)
  M <- assays(rnaseq_data_pr_subset)$logCPM[, i] - A
  smoothScatter(A, M, main=colnames(rnaseq_data_pr_subset)[i], las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

Then, the individual MA-plots after filtering and normalization. 
```{r MA_plot_after_filter}
# Print them 4 at a time
par(mfrow=c(2, 2), mar=c(4, 5, 1, 1))

# MA-plot generation
for (i in 1:ncol(rnaseq_data_pr_subset.filt)) {
  A <- rowMeans(assays(rnaseq_data_pr_subset.filt)$logCPM)
  M <- assays(rnaseq_data_pr_subset.filt)$logCPM[, i] - A
  smoothScatter(A, M, main=colnames(rnaseq_data_pr_subset.filt)[i], las=1)
  abline(h=0, col="blue", lwd=2)
  lo <- lowess(M ~ A)
  lines(lo$x, lo$y, col="red", lwd=2)
}
```

It can be seen that there are some small differences between the individual sample expression trends (red line) and the average expression across all the samples (blue line). In addition, as lowly-expressed genes have been filtered out, the differences observed in lowly-expressed genes in the "before filtering" graphs has been reduced, focus on the genes with higher and more reliable levels of expression. 

Next, a smear plot will be done to compare `Primary solid Tumor` and ` Recurrent Solid Tumor`as groups. As before, a graph before filtering and another after filtering will be carried out.
```{r comparing_by_groups}
# Print the graphs together
par(mfrow=c(2, 1), mar=c(4, 5, 1, 1))

# Assign the type of samples to the DGEList objects
dge_subset$samples$group <- rnaseq_data_pr_subset$definition
dge_subset.filt$samples$group <- rnaseq_data_pr_subset$definition

# MA-plot before filtering
plotSmear(dge_subset, lowess=TRUE, las=1, cex.lab=1.5, cex.axis=1.2)
abline(h=0, col="blue", lwd=2)

# MA-plot after filtering
plotSmear(dge_subset.filt, lowess=TRUE, las=1, cex.lab=1.5, cex.axis=1.2)
abline(h=0, col="blue", lwd=2)

```

In this case, the blue line represents equal expression of the genes between the two types of samples, while the red line portrays the differences in expression between the groups. Therefore, deviations of the red line from the blue line signal that there are genes that may be differentially expressed . Additionally, as this is only an example of one group, it is possible that another group with other samples might give more or less deviation.

# Batch identification and experimental design

In order to detect possible batches that can interfere in the analysis, a hierarchical  clustering is carried out.
```{r batch_identification_hierarchical_clustering}
# Calculate log CPM values with a prior.count of 3 to moderate extreme fold-changes produced by low counts
logCPM <- cpm(dge_subset.filt, log=TRUE, prior.count=3)

# Calculate the distance matrix using Spearman correlation
d <- as.dist(1-cor(logCPM, method="spearman"))

# Perform hierarchical clustering
sampleClustering <- hclust(d)

# To observe gender as a possible batch effect, an object will be created for later use to color each sample's gender
batch <- as.integer(rnaseq_data_pr_subset.filt$gender)
names(batch) <- colnames(rnaseq_data_pr_subset.filt)

# Create a dendrogram object with the hierarchical clustering 
sampleDendrogram <- as.dendrogram(sampleClustering, hang=0.1)

# Create the labels that will be seen in the dendrogram
outcome <- paste(rnaseq_data_pr_subset.filt$shortLetterCode, ' (', rnaseq_data_pr_subset.filt$race, ')', sep="")
names(outcome) <- colnames(rnaseq_data_pr_subset.filt)

# Modify dendrogram labels and color
sampleDendrogram <- dendrapply(sampleDendrogram,
                               function(x, batch, labels) {
                                 if (is.leaf(x)) {
                                   attr(x, "nodePar") <- list(lab.col=as.vector(batch[attr(x, "label")]))
                                   attr(x, "label") <- as.vector(labels[attr(x, "label")])
                                 }
                                 x
                               }, batch, outcome)

# Plot the dendrogram
par(mar = c(12, 4, 4, 2)) 
plot(sampleDendrogram, main="Hierarchical clustering of samples",
     cex=0.7, cex.axis = 0.6, las = 2)
legend("topright", levels(rnaseq_data_pr_subset.filt$gender),
       fill=seq_len(nlevels(rnaseq_data_pr_subset.filt$gender)))
```

Thanks to the dendrogram, it can be seen that the distribution of the samples is homogeneous, primary tumor samples do not cluster together and neither do the recurrent tumor samples. Moreover, neither race nor gender appear to be causing a batch effect, as they are also dispersed in the dendrogram, instead of clustering together. 

Another way to determine batches is through a Multidimensional Scaling (MDS) plot.
```{r batch_identificatio_nmps_graph}
# Creating the labels of the samples
outcome <- paste(rnaseq_data_pr_subset.filt$shortLetterCode, ' (', rnaseq_data_pr_subset.filt$race, ')', sep="")
names(outcome) <- colnames(rnaseq_data_pr_subset.filt)

# Creating the MDS plot
plotMDS(dge_subset.filt, labels=outcome, col=batch)
legend("right", levels(rnaseq_data_pr_subset.filt$gender),
       fill=seq_len(nlevels(rnaseq_data_pr_subset.filt$gender)), inset=0.05)
```
As with the dendrogram, it can't be seen different clusers for neither tumor stage, race or gender.

# Differential expression analysis

In order to start the DEA; first the levels of the target variable are modified to make the healthy samples as references, this way, all results will be of the primary tumor samples compared to the recurrent tumor samples. Moreover, the model for the analysis is created, despite the results, both  race and gender were tried to add as covariates, however, race gave a computationally singular system, therefore, of the two, only  gender has been added. Moreover, the ages at diagnosis and at index will be also added
```{r define_the_reference}
# Eliminating non-important or repeated variables
colData(rnaseq_data_pr_subset.filt) <- as(colData(rnaseq_data_pr_subset.filt), "data.frame") %>%
  select(barcode, patient, sample, definition, intermediate_dimension, shortest_dimension, longest_dimension, 
         age_at_diagnosis, race, gender, ethnicity, vital_status, age_at_index, 
         paper_Tissue.source.site, days_to_death, paper_Original.Subtype) %>%
  as("DFrame")

# Define the reference
rnaseq_data_pr_subset.filt$definition <- relevel(rnaseq_data_pr_subset.filt$definition, ref="Recurrent Solid Tumor")

# Creating the model for the analysis
mod <- model.matrix(~ definition+ gender + age_at_diagnosis + age_at_index , data=colData(rnaseq_data_pr_subset.filt))
head(mod, 15)
```

Although some possible confounding effects were tested for, there might be others that are being missed, hidden batch effects. To avoid this, a Surrogate Variable Analysis (SVA) will be carried out.
```{r SVA}
# Creating a model to compare the previously created against
mod0 <- model.matrix(~ gender + age_at_diagnosis + age_at_index, colData(rnaseq_data_pr_subset.filt))

# Carry out the SVA analysis
sv <- sva(assays(rnaseq_data_pr_subset.filt)$logCPM, mod=mod, mod0=mod0)
```

Thanks to the results fo the analysis, 5 significant surrogate variables are obtained.

In order to see their significance, a Singular Value Decomposition (SVD) is done to see the amount of contribution to the variance by each surrogate variable
```{r SVA_SVD}
# Perform SVD on the logCPM values
svd_result <- svd(scale(assays(rnaseq_data_pr_subset.filt)$logCPM))
eigenvalues <- svd_result$d^2

# Plot eigenvalues
plot(eigenvalues, type = "b", xlab = "Component", ylab = "Eigenvalue", main = "SVD Eigenvalues")
```

According to the SVA results, there are five surrogate variables, and as can be seen in teh graph, most of the variance is explained by the first one. It can be seen a slight elbow with the fifth component. The 5 surrogate variables will be used to take into account for the variance unrelated to the "Primary tumor vs Recurrent tumor" differences, helping to mitigate the noise and potential confounding effects. 

The model is modified to take the surrogate variables into account. Then the DEA is carried out with `voomLmFit`from the package `EdgeR` [@edgeR], and with `eBayes`from the package `limma` [@limma]
```{r t-statistic}
# Addition of the SVA surregate variables
mod <- cbind(mod, sv$sv)

# Carry out the Differential Expression Analysis
fit <- voomLmFit(dge_subset.filt, mod, block= rnaseq_data_pr_subset$patient)
fit <- eBayes(fit)
```

The results of the DEA can be found in the object `fit`.

In `fit`, the genes do not appear as their symbols, to make it more understandable, the Ensembl code [@Ensembl2024] will be changed by the genes' symbols. 
```{r gene_data}
genesmd <- data.frame(chr=as.character(seqnames(rowRanges(rnaseq_data_pr_subset.filt))),
                        symbol=rowData(rnaseq_data_pr_subset.filt)[, 7], description=rowData(rnaseq_data_pr_subset.filt)[, 6],
                      EntrezID = rownames(rnaseq_data_pr_subset.filt), stringsAsFactors=FALSE)
fit$genes <- genesmd
```

Before proceeding, correction for multiple testing is necessary, for it, the function `topTable()` is used. This function uses Benjamini-Hochberg FDR (Flase Discovery Rate) as method for correction.
Moreover, the amount of genes that are overexpressed, underexpressed or stays the same in healthy samples (intercept) will also be printed.
```{r multiple_test_correction}
# Multiple testing correction
tt <- topTable(fit, coef=2, n=Inf)

# Genes divided by change in expression
res <- decideTests(fit, p.value=0.1)
print(summary(res))
```

A plot with the distribution of the P.values for each gene is created.
```{r pvalues}
# Create a histogram with the P.values
h <- hist(tt$P.Value, xlab="Raw P-values", main="",
          las=1)
```
It can be seen that the p.vlaues are homogenoeus, so not many P-values will be under the threshold 0.1.

A volcano plot is also created to see which genes are more differentially expressed, either underexpressed or overexpressed.
```{r volcano}
# Create the volcano plot
volcanoplot(fit, coef=2, highlight=10, names=fit$genes$symbol,
            main="", las = 1)
```
Many genes appear to be underexpressed in primary tumor samples, like IGHM, IGHG1, ZNF792, Ac005670... and many otehr appear to be overexpressed in the top differentially expressed genes, like  BTNL9, LINO008, SNHG12, EP400P1...

In addition, an MA-plot will also be created to also represent the differentially expressed genes distribution.
```{r MA_plots_after}
# Obtaining the name of the top 10 DEG
top10 <- order(fit$lods[, 2], decreasing=TRUE)[1:10]

# Filter for genes with less than a 0.1 adjusted P.value
DEgenes <- rownames(tt)[tt$adj.P.Val < 0.1]

# Createing the MA-plot
limma::plotMA(fit, coef=2, status=rownames(fit$lods) %in% DEgenes, legend=FALSE,
              main="", hl.pch=46, hl.cex=4, bg.pch=46, bg.cex=3, las =1)
text(fit$Amean[top10], fit$coef[top10, 2], fit$genes$symbol[top10], cex=0.5, pos=4)
```

To have the complete list of differentially expressed genes, a final filter is undergone, only those that after the correction have an adjusted P.value of less than 0.1 will be kept.
```{r DGE_list}
DEGtable <- tt %>% filter(adj.P.Val < 0.1) %>% arrange(P.Value)
if (nrow(DEGtable) >0){
  rownames(DEGtable) <- 1:nrow(DEGtable)
}
```

In this case, no gene has been classified as differentially expressed, as none obtained an adjusted P.value lower than 0.1.

However, as previously stated, this example was only to determine which factors to take into account for the rest of the groups, for example: using the sva data, and variables like gender, but not use variables such as race.

# Carrying out the 1000 DEAs

In order to obtain results using all the data available, multiple groups of 13 primary tumor samples will be created, and the same path will be followed (without the graphics, to optimize performance), obtaining the list of all comparisons.

```{r loop}
# Defining the objects where the results will be stored
results<- data.frame(assay=character(), symbol=character(), logFC=numeric(), adjPvalue=numeric())
samples_selected <- vector("list", 1000)
# Carry out the multiple DEAs
for (i in 1:1000){
  # Counter in order to know in which comparison it is
  print(i)
  
  # Randomly select 5 samples from "Primary solid Tumor"
  random_primary_tumor_samples <- sample(primary_tumor_samples, 13)
  samples_selected[[i]]<- random_primary_tumor_samples
  
  # Combine healthy samples and the randomly selected primary tumor samples.
  selected_samples <- c(r_tumor_samples, random_primary_tumor_samples)

  # Subset the SummarizedExperiment object with the selected samples
  rnaseq_data_pr_subset <- rnaseq_data_pr[, colnames(rnaseq_data_pr) %in% selected_samples]

  # Subset the previous DGEList object
  dge_subset <- dge[, colnames(dge) %in% selected_samples]
  
  # Filtering lowly expressed genes
  mask <- rowMeans(assays(rnaseq_data_pr_subset)$logCPM) > 1
  rnaseq_data_pr_subset.filt <- rnaseq_data_pr_subset[mask, ]
  dge_subset.filt <- dge_subset[mask, ]
  
  # Between-sample normalization
  dge_subset.filt <- calcNormFactors(dge_subset.filt, method = 'TMM')
  assays(rnaseq_data_pr_subset.filt)$logCPM <- cpm(dge_subset.filt, log=TRUE,
                              normalized.lib.sizes=TRUE)
  
  # Differential expression analysis
  colData(rnaseq_data_pr_subset.filt) <- as(colData(rnaseq_data_pr_subset.filt), "data.frame") %>%
  select(barcode, patient, sample, definition, intermediate_dimension, shortest_dimension, longest_dimension, 
         age_at_diagnosis, race, gender, ethnicity, vital_status, age_at_index, 
         paper_Tissue.source.site, days_to_death, paper_Original.Subtype) %>%
  as("DFrame")
  rnaseq_data_pr_subset.filt$definition <- relevel(rnaseq_data_pr_subset.filt$definition, ref="Recurrent Solid Tumor")
  mod <- model.matrix(~ definition + gender + age_at_diagnosis + age_at_index, data=colData(rnaseq_data_pr_subset.filt))
  mod0 <- model.matrix(~ gender + age_at_diagnosis + age_at_index, colData(rnaseq_data_pr_subset.filt))
  sv <- sva(assays(rnaseq_data_pr_subset.filt)$logCPM, mod=mod, mod0=mod0)
  mod <- cbind(mod, sv$sv)
  fit <- voomLmFit(dge_subset.filt, mod, block = rnaseq_data_pr_subset$patient)
  fit <- eBayes(fit)
  genesmd <- data.frame(chr=as.character(seqnames(rowRanges(rnaseq_data_pr_subset.filt))),
                        symbol=rowData(rnaseq_data_pr_subset.filt)[, 7], description=rowData(rnaseq_data_pr_subset.filt)[, 6],
                      EntrezID = rownames(rnaseq_data_pr_subset.filt), stringsAsFactors=FALSE)
  fit$genes <- genesmd
  tt <- topTable(fit, coef=2, n=Inf)
  DEGtable <- tt %>% filter(adj.P.Val < 0.1) %>% arrange(P.Value)
  if (nrow(DEGtable) != 0){
    rownames(DEGtable) <- 1:nrow(DEGtable)
      # Obtaining the important information from the results
 print("adding results")
 new_entry<-cbind(i, DEGtable %>% select(symbol, logFC, adj.P.Val))
 colnames(new_entry)<-colnames(results)
 results<-rbind(results, new_entry)
  }
}
```


# Analysing the results

After obtaining the list with all the differentially expressed genes in `results`, a count table is created to see how many times each of the wanted genes for the study appears in the results of the analyses.
```{r count_matrix_creation}
# Filtering for the wanted genes 
study_genes <- c("CDH1","CDH2","L1CAM","EPCAM", "EGFR", "NANOG", "ALDH1A1", "OCT4", "ABCG2", "HRAS", "KRAS","NRAS", "GAPDH", "PIK3CB")
results_filtered <- results %>% filter(symbol %in% study_genes)

# Creating the count table
gene_counts <- table(results_filtered$symbol)

# Convert the table to a data frame
gene_count_df <- as.data.frame(gene_counts)
colnames(gene_count_df) <- c("Gene", "Count")
rownames(gene_count_df) <- gene_count_df[,1]
```

Revising the distribution of the results might give an insight of them.
```{r DEG_distribution}
# A data frame with the possible ranges of number of counts
bins <- data.frame(Count_Bin = factor(
  levels(cut(0, breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE)),
  levels = unique(cut(seq(0, 1000, by = 1), breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE))
))

# Object that will divide the genes in groups depending on the number of DEAs they have appeared as a DEG
gene_count_summary <- gene_count_df %>%
  mutate(Count_Bin = cut(Count, breaks = seq(0, 1000, by = 100), right = FALSE, include.lowest = TRUE)) %>%
  group_by(Count_Bin) %>%
  summarize(Num_Genes = n()) %>%
  right_join(bins, by = "Count_Bin") %>%
  replace_na(list(Num_Genes = 0))

# Plot the distribution
ggplot(gene_count_summary, aes(x = Count_Bin, y = Num_Genes)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(
    title = "Distribution of Gene Counts by Range",
    x = "Count Range",
    y = "Number of Genes"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

It can be seen that only 10 of the original 14 have appeared as a DEG in at least 1 DEA, all of them appearing in between 0 and 100 DEAs. Despite this, even though multiple testing correction has been taken into account independently in each DEA, as 1000 analyses have been performed, another multiple testing correction must be applied to take into account the number of analyses carried out.  
```{r FDR}
# Creation of the object that will store the results after multiple testing correction
results_fdr <- matrix(nrow=0, ncol=4)

# Obtaining the newly adjusted P.values with FDR modifying the adjusted P.values obtained from the DEAs
for (i in 1:nrow(gene_count_df)){
  gene_pvalues<- results_filtered %>% filter(symbol == gene_count_df[i, "Gene"])
  adjusted_pvalues <- p.adjust(gene_pvalues$adjPvalue, method = "fdr", n=1000)
  copy_data <- results_filtered %>% filter(symbol==gene_count_df[i, "Gene"])
  copy_data$adjPvalue <- adjusted_pvalues
  results_fdr<- rbind(results_fdr, copy_data)
}

# Filter the adjusted P.values using a cutoff of  0.1
results_fdr <- results_fdr %>% filter(adjPvalue < 0.1)

# Count the frequency of each gene across all comparisons
gene_counts_df_fdr <- table(results_fdr$symbol)
print(gene_count_df_fdr)
```

Now, the object `gene_count_df_fdr` carries the number of times each gene has appeared as a DEG after eliminating the possible false positives. No positive has remained, losing all 10 remaining genes as possible DEGs.

# Conclusion

Thanks to these results, it can be understood that there are no differences in expression between `Primary solid Tumor` samples and `Recurrent Solid Tumor samples` for the target genes observed in this study.